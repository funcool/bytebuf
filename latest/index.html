<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.2">
<meta name="author" content="funcool.org">
<title>octet - a library for working with byte buffers</title>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments, .listingblock .pygments code { background: #f0f0f0; }
.listingblock .pygments .tok-c { color: #60a0b0; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #007020; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-ch { color: #60a0b0; font-style: italic } /* Comment.Hashbang */
.listingblock .pygments .tok-cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #007020 } /* Comment.Preproc */
.listingblock .pygments .tok-cpf { color: #60a0b0; font-style: italic } /* Comment.PreprocFile */
.listingblock .pygments .tok-c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #007020 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #902000 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #40a070 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #4070a0 } /* Literal.String */
.listingblock .pygments .tok-na { color: #4070a0 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #007020 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #60add5 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #d55537; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #007020 } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #06287e } /* Name.Function */
.listingblock .pygments .tok-nl { color: #002070; font-weight: bold } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #062873; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #bb60d5 } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #007020; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #40a070 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #40a070 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #40a070 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #40a070 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #40a070 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sa { color: #4070a0 } /* Literal.String.Affix */
.listingblock .pygments .tok-sb { color: #4070a0 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #4070a0 } /* Literal.String.Char */
.listingblock .pygments .tok-dl { color: #4070a0 } /* Literal.String.Delimiter */
.listingblock .pygments .tok-sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #4070a0 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #4070a0 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #c65d09 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #235388 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #4070a0 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #517918 } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-fm { color: #06287e } /* Name.Function.Magic */
.listingblock .pygments .tok-vc { color: #bb60d5 } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #bb60d5 } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #bb60d5 } /* Name.Variable.Instance */
.listingblock .pygments .tok-vm { color: #bb60d5 } /* Name.Variable.Magic */
.listingblock .pygments .tok-il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Liberation+Mono:400|Roboto+Slab:400,700"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/asciidoctor.js/1.5.5-5/css/asciidoctor.min.css"/>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>octet - a library for working with byte buffers</h1>
<div class="details">
<span id="author" class="author">funcool.org</span><br>
<span id="revdate">1.1.1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#_project_maturity">1.1. Project Maturity</a></li>
<li><a href="#_install">1.2. Install</a></li>
</ul>
</li>
<li><a href="#_getting_started">2. Getting started</a>
<ul class="sectlevel2">
<li><a href="#_define_a_spec">2.1. Define a spec</a></li>
<li><a href="#_creating_buffer">2.2. Creating buffer</a></li>
<li><a href="#_read_and_write_data">2.3. Read and write data</a></li>
</ul>
</li>
<li><a href="#_advanced_usage">3. Advanced usage</a>
<ul class="sectlevel2">
<li><a href="#_read_write_with_offset">3.1. Read &amp; Write with offset.</a></li>
<li><a href="#_show_readed_bytes">3.2. Show readed bytes.</a></li>
<li><a href="#_read_write_repeatedly">3.3. Read &amp; Write repeatedly</a></li>
<li><a href="#_using_arbitrary_size_type_specs">3.4. Using arbitrary size type specs</a></li>
<li><a href="#_put_data_into_new_buffer">3.5. Put data into new buffer</a></li>
<li><a href="#_vectors">3.6. Vectors</a></li>
<li><a href="#_read_and_write_spec_to_multiple_byte_buffers">3.7. Read and write spec to multiple byte buffers</a></li>
<li><a href="#_define_own_type_spec">3.8. Define own type spec</a></li>
</ul>
</li>
<li><a href="#_additional_info">4. Additional info</a>
<ul class="sectlevel2">
<li><a href="#supported-bytebuffers">4.1. Supported byte buffers</a></li>
<li><a href="#_supported_typespecs">4.2. Supported typespecs</a></li>
<li><a href="#_byte_order">4.3. Byte order</a></li>
</ul>
</li>
<li><a href="#_faq">5. FAQ</a></li>
<li><a href="#_how_to_contribute">6. How to Contribute?</a>
<ul class="sectlevel2">
<li><a href="#_philosophy">6.1. Philosophy</a></li>
<li><a href="#_contributing">6.2. Contributing</a></li>
<li><a href="#_source_code">6.3. Source Code</a></li>
<li><a href="#_run_tests">6.4. Run tests</a></li>
<li><a href="#_license">6.5. License</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction"><a class="link" href="#_introduction">1. Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Working with raw bytes is tedious, and sometimes the language abstractions for
working with bytes is not very pleasant. <em>octet</em> library offers a simple api for
clojure (jvm) and clojurescript (js) that makes working with bytebuffer painless.</p>
</div>
<div class="paragraph">
<p>This is a short list of project goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Not to be intrusive (no bytebuffer wrapping).</p>
</li>
<li>
<p>Provide host independent abstraction (in most possible way).</p>
</li>
<li>
<p>Composability.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_project_maturity"><a class="link" href="#_project_maturity">1.1. Project Maturity</a></h3>
<div class="paragraph">
<p>Since <em>octet</em> is a young project there can be some API breakage.</p>
</div>
</div>
<div class="sect2">
<h3 id="_install"><a class="link" href="#_install">1.2. Install</a></h3>
<div class="paragraph">
<p>The simplest way to use <em>octet</em> in a clojure project, is by including it in the
dependency vector on your <strong><em>project.clj</em></strong> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">[</span><span class="tok-nv">funcool/octet</span> <span class="tok-s">&quot;1.1.1&quot;</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the library works with the following platforms: <strong>jdk7</strong>, <strong>jdk8</strong>, <strong>node-lts</strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_started"><a class="link" href="#_getting_started">2. Getting started</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main goal of <em>octet</em> is provide, multiplatform abstraction for work with
byte buffer&#8217;s. Offering a ligweight api for define message types in a declarative
way and use them for read or write to bytebuffers.</p>
</div>
<div class="paragraph">
<p>As previously said, <em>octet</em>  works with both most used clojure implementations:
clojure &amp; clojurescript. Each platform has its own byte buffer abstraction:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html">NIO ByteBuffer (clojure)</a></p>
</li>
<li>
<p><a href="http://netty.io/4.1/api/io/netty/buffer/ByteBuf.html">Netty ByteBuf (clojure)</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Typed_arrays">Typed Arrays ES6 (clojurescript)</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_define_a_spec"><a class="link" href="#_define_a_spec">2.1. Define a spec</a></h3>
<div class="paragraph">
<p>A spec in <em>octet</em> glossary represents a type definition or a composition of types.
Two most common composition types are: associative and indexed.</p>
</div>
<div class="paragraph">
<p>The difference of indexed and associative compositions is the input and output. In
associative composition the expected input and output is a map. And in indexed
composition, the expected input and input is a vector. Internally them represents
the same value in bytes.</p>
</div>
<div class="paragraph">
<p>Let start defining one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">octet.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">buf</span><span class="tok-p">])</span>

<span class="tok-c1">;; Indexed composition</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">my-spec1</span> <span class="tok-p">(</span><span class="tok-nf">buf/spec</span> <span class="tok-nv">buf/int32</span> <span class="tok-nv">buf/bool</span><span class="tok-p">))</span>

<span class="tok-c1">;; The same spec but using associative composition</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">my-spec2</span> <span class="tok-p">(</span><span class="tok-nf">buf/spec</span> <span class="tok-ss">:field1</span> <span class="tok-nv">buf/int32</span>
                        <span class="tok-ss">:field2</span> <span class="tok-nv">buf/bool</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can check that the spec size (in bytes) and number of types internally is the
same for both:</p>
</div>
<div class="listingblock">
<div class="title">Example using <code>size</code> and <code>count</code> functions on specs</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/size</span> <span class="tok-nv">my-spec1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 5</span>

<span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">my-spec1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nf">buf/size</span> <span class="tok-nv">my-spec2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 5</span>

<span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">my-spec2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_buffer"><a class="link" href="#_creating_buffer">2.2. Creating buffer</a></h3>
<div class="paragraph">
<p>The next piece in the puzzle is a way to create (or allocate) new byte buffers.
This operation is almost platform independent if the library defaults satisfies you.</p>
</div>
<div class="listingblock">
<div class="title">Example allocating a 24 bytes size byte buffer with <strong>default</strong> implementation</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-c1">;; Allocate bytebuffer with 24 bytes of size</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">buffer</span> <span class="tok-p">(</span><span class="tok-nf">buf/allocate</span> <span class="tok-mi">24</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The buffer allocation is parametrizable so you can specify the concrete
implementation to use and the type of buffer:</p>
</div>
<div class="listingblock">
<div class="title">Example allocation 24 bytes size buffer with nio buffer implementation</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-c1">;; This is a default if you are using clojure</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">buffer</span> <span class="tok-p">(</span><span class="tok-nf">buf/allocate</span> <span class="tok-mi">24</span> <span class="tok-p">{</span><span class="tok-ss">:impl</span> <span class="tok-ss">:nio</span> <span class="tok-ss">:type</span> <span class="tok-ss">:heap</span><span class="tok-p">}))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It there are two types of buffers: <code>:heap</code> and <code>:direct</code>. The <code>:heap</code> type of buffer
uses the jdk/node heap for store the data and the <code>:direct</code> buffer type stores
the data out of the virtual machine heap. The main advantage of use <code>:direct</code>
buffers is that they are not affect the GC and may enable have less GC pauses.</p>
</div>
<div class="paragraph">
<p>The <code>:direct</code> type of buffers are only available on JDK.</p>
</div>
<div class="paragraph">
<p>Example allocating a 24 bytes size byte buffer using <strong>es6typed arrays</strong> implementation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-c1">;; This is a default if you are using clojurescript</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">buffer</span> <span class="tok-p">(</span><span class="tok-nf">buf/allocate</span> <span class="tok-mi">24</span> <span class="tok-p">{</span><span class="tok-ss">:impl</span> <span class="tok-ss">:es6</span> <span class="tok-ss">:type</span> <span class="tok-ss">:heap</span><span class="tok-p">}))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see all supported options <a href="#supported-bytebuffers">here</a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The return value of <code>allocate</code> depens on implementation used. Is a plain instance
without additional wrapping. If you want access to its internals, you can do it
with native host platform api.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_read_and_write_data"><a class="link" href="#_read_and_write_data">2.3. Read and write data</a></h3>
<div class="paragraph">
<p>It&#8217;s time to see how we can write data to buffers and read data from them using
specs. Specs are simple schema on how the data should be read or write to the buffer.</p>
</div>
<div class="listingblock">
<div class="title">Example writing data into buffer using indexed composed schema</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-c1">;; The indexed composed spec exptects a vector as input</span>
<span class="tok-p">(</span><span class="tok-nf">buf/write!</span> <span class="tok-nv">buffer</span> <span class="tok-p">[</span><span class="tok-mi">22</span> <span class="tok-nv">true</span><span class="tok-p">]</span> <span class="tok-nv">my-spec1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>write!</code> function  returns a number of bytes are written into buffer.</p>
</div>
<div class="paragraph">
<p>As, previously mentioned, indexed and associative specs with same fields (in same
order) represents the identical layout. Knowing that, we also can do the same
operation but using the associative spec defined previously:</p>
</div>
<div class="listingblock">
<div class="title">Example writing data into buffer using a map as input</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/write!</span> <span class="tok-nv">buffer</span> <span class="tok-p">{</span><span class="tok-ss">:field1</span> <span class="tok-mi">22</span> <span class="tok-ss">:field2</span> <span class="tok-nv">true</span><span class="tok-p">}</span> <span class="tok-nv">my-spec2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 5</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Some buffer implementations (nio is an example) has the concept of read or
write position. <em>octet</em> doesn&#8217;t touch that.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Secondly, the read operation is mostly similar to write one. It reads from buffer
following the spec and return corresponding data structure:</p>
</div>
<div class="listingblock">
<div class="title">Example reading from buffer using indexed spec</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffer</span> <span class="tok-nv">my-spec1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [22 true]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, you can perform the same operation, but using a associative spec:</p>
</div>
<div class="listingblock">
<div class="title">Example reading from buffer using associative spec</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffer</span> <span class="tok-nv">my-spec2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:field1 22 :field2 true}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This works idependently of implementation used for allocate the buffer. Some
implementations has little limitations, es6 (cljs) as example, des not support
<code>int64</code> typespec due to platform limitations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Composed type specs and plain value type specs implements the same abstraction and
both can be used directly in read and write operations:</p>
</div>
<div class="listingblock">
<div class="title">Example using plain specs for read data from buffers</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffer</span> <span class="tok-p">(</span><span class="tok-nf">buf/int16</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 22</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_usage"><a class="link" href="#_advanced_usage">3. Advanced usage</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_read_write_with_offset"><a class="link" href="#_read_write_with_offset">3.1. Read &amp; Write with offset.</a></h3>
<div class="paragraph">
<p>If you know that the data what you want read is located in a specific position in
a buffer, you can specify it in a read or write operation:</p>
</div>
<div class="listingblock">
<div class="title">Example writing data in specific offset</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/write</span> <span class="tok-nv">buffer</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-nv">false</span><span class="tok-p">]</span> <span class="tok-nv">my-spec1</span> <span class="tok-p">{</span><span class="tok-ss">:offset</span> <span class="tok-mi">20</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; [0 false]</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example read data from specific offset.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffer</span> <span class="tok-nv">my-spec1</span> <span class="tok-p">{</span><span class="tok-ss">:offset</span> <span class="tok-mi">20</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; [0 false]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_show_readed_bytes"><a class="link" href="#_show_readed_bytes">3.2. Show readed bytes.</a></h3>
<div class="paragraph">
<p>The default <code>read</code> function returns readed data but not returns a amount of readed
bytes. For it, <em>octet</em> exposes a convenience function <code>read*</code> that instead of
return only readed data, returns a vector with amount of bytes readed and the
readed data:</p>
</div>
<div class="listingblock">
<div class="title">Example using <code>read*</code> function</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/read*</span> <span class="tok-nv">buffer</span> <span class="tok-nv">my-spec2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [5 {:field1 22 :field2 true}]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_read_write_repeatedly"><a class="link" href="#_read_write_repeatedly">3.3. Read &amp; Write repeatedly</a></h3>
<div class="paragraph">
<p>Sometimes you will want read some spec repeatedly, for that purpose <em>octet</em> comes
with <code>repeat</code> composition function:</p>
</div>
<div class="listingblock">
<div class="title">Example for read and write using repeat composed spec</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">spec</span> <span class="tok-p">(</span><span class="tok-nf">buf/repeat</span> <span class="tok-mi">5</span> <span class="tok-nv">buf/int32</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-nf">buf/write</span> <span class="tok-nv">buffer</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span> <span class="tok-nv">spec</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 20</span>

<span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffer</span> <span class="tok-nv">spec</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3 4 5]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_arbitrary_size_type_specs"><a class="link" href="#_using_arbitrary_size_type_specs">3.4. Using arbitrary size type specs</a></h3>
<div class="paragraph">
<p>Until now, we have seen examples alway using fixed size compositions. Fixed size
compositions are easy understand, the size of the spec can be know in any time.
But in some circumstances we want store arbitrary length. Strings are one great
example:</p>
</div>
<div class="listingblock">
<div class="title">Example writing arbitrary length string into buffer</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/write!</span> <span class="tok-nv">buffer</span> <span class="tok-s">&quot;hello world&quot;</span> <span class="tok-nv">buf/string*</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 15</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example reading arbitrary length string from buffer</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffer</span> <span class="tok-p">(</span><span class="tok-nf">buf/string*</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; &quot;hello world&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But, how it works? Type specs like that, is a composition of two typespecs: <strong>int32</strong>
and fixed length <strong>string</strong>. On write phase, it calculates the size of string,
writes firstly the size as <code>int32</code> following of fixed size string. The read phase
is like write but in backward direction.</p>
</div>
<div class="paragraph">
<p>Also, the size of that type spec depends on data and can not be known outsize of
read/write phase:</p>
</div>
<div class="listingblock">
<div class="title">Example how obtain a size of specific type spec</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">buf/size</span> <span class="tok-nv">buf/int16</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nf">buf/size</span> <span class="tok-nv">buf/string*</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; IllegalArgumentException No implementation of method: :size of protocol: #&#39;octet.spec/ISpecSize found for class: octet.spec.string$string_STAR_$reify__1804  clojure.core/-cache-protocol-fn (core_deftype.clj:555)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_put_data_into_new_buffer"><a class="link" href="#_put_data_into_new_buffer">3.5. Put data into new buffer</a></h3>
<div class="paragraph">
<p>This is a some kind of helper, that allows easy create a buffer with exactly size
for concrete spec and concrete data. It works perfectly with static size specs and
arbitrary size specs.</p>
</div>
<div class="listingblock">
<div class="title">Example using <code>octet.core/into</code> function (semantically similar to clojure&#8217;s <code>into</code>)</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">myspec</span> <span class="tok-p">(</span><span class="tok-nf">buf/spec</span> <span class="tok-nv">buf/string*</span> <span class="tok-nv">buf/string*</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">buffer</span> <span class="tok-p">(</span><span class="tok-nf">buf/into</span> <span class="tok-nv">myspec</span> <span class="tok-p">[</span><span class="tok-s">&quot;hello&quot;</span> <span class="tok-s">&quot;world!&quot;</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">buf/get-capacity</span> <span class="tok-nv">buffer</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 19</span>

<span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffer</span> <span class="tok-nv">myspec</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [&quot;hello&quot;, &quot;world!&quot;]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_vectors"><a class="link" href="#_vectors">3.6. Vectors</a></h3>
<div class="paragraph">
<p>This is a very similar abstraction to the previously explained repeating pattern.
The main difference with it is that this one represents an arbitrary size repetition
of one spec and allows store an array like datastructures.</p>
</div>
<div class="listingblock">
<div class="title">Example storing two arrays in a buffer</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">spec</span> <span class="tok-p">(</span><span class="tok-nf">buf/spec</span>
            <span class="tok-p">(</span><span class="tok-nf">buf/vector*</span> <span class="tok-nv">buf/int32</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nf">buf/vector*</span> <span class="tok-nv">buf/int32</span><span class="tok-p">)))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">buffer</span> <span class="tok-p">(</span><span class="tok-nf">buf/into</span> <span class="tok-nv">spec</span> <span class="tok-p">[[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span> <span class="tok-mi">7</span> <span class="tok-mi">8</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">buf/get-capacity</span> <span class="tok-nv">buffer</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 40</span>

<span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffer</span> <span class="tok-nv">spec</span><span class="tok-p">)</span>
<span class="tok-p">[[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span> <span class="tok-mi">7</span> <span class="tok-mi">8</span><span class="tok-p">]]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Behind the scenes, an vector is represented with as <code>int32 + type*N</code>, that means
that it has always an overhead of 4 bytes for store the length of the vector.</p>
</div>
</div>
<div class="sect2">
<h3 id="_read_and_write_spec_to_multiple_byte_buffers"><a class="link" href="#_read_and_write_spec_to_multiple_byte_buffers">3.7. Read and write spec to multiple byte buffers</a></h3>
<div class="paragraph">
<p>In some circumstances (specially when we working with streams) the buffers are
splitted. The simplest but not very efficient approach will be copy all data in one
unique byte buffer and read a spec from it. Octet comes with facilities for read a
spec from a vector of buffers that prevents unnecesary copy action.</p>
</div>
<div class="listingblock">
<div class="title">Example reading and writing data to a vector of buffers</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">myspec</span> <span class="tok-p">(</span><span class="tok-nf">buf/spec</span> <span class="tok-nv">buf/short</span> <span class="tok-nv">buf/int32</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">buffers</span> <span class="tok-p">[(</span><span class="tok-nf">buf/allocate</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
              <span class="tok-p">(</span><span class="tok-nf">buf/allocate</span> <span class="tok-mi">4</span><span class="tok-p">)])</span>

<span class="tok-p">(</span><span class="tok-nf">buf/write!</span> <span class="tok-nv">buffers</span> <span class="tok-p">[</span><span class="tok-mi">20</span> <span class="tok-mi">30</span><span class="tok-p">]</span> <span class="tok-nv">myspec</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 6</span>

<span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffers</span> <span class="tok-nv">spec</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [20 30]</span>

<span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">buffers</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-nv">buf/short</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 20</span>

<span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">buffers</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-nv">buf/int32</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 30</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_define_own_type_spec"><a class="link" href="#_define_own_type_spec">3.8. Define own type spec</a></h3>
<div class="paragraph">
<p>In some circumstances, you probably need define own typespec for solve concrete
situations. <em>octet</em> is build around abstractions and define new type spec is not
very complicated job.</p>
</div>
<div class="paragraph">
<p>An typespec consists mainly in <code>ISpec</code> protocol that has two methods: <code>read</code> and
<code>write</code>. Let see an example defining a typespec for point of coordenades:</p>
</div>
<div class="listingblock">
<div class="title">Example definition of type spec that represents a point</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">octet.spec</span> <span class="tok-ss">:as</span> <span class="tok-nv">spec</span><span class="tok-p">])</span>

<span class="tok-c1">;; Imagine you have a type Point defined like this:</span>
<span class="tok-p">(</span><span class="tok-kd">defrecord </span><span class="tok-nv">Point</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">])</span>

<span class="tok-c1">;; Type spec definition for read/write Point instances.</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">point-spec</span>
  <span class="tok-p">(</span><span class="tok-nf">reify</span>
    <span class="tok-nv">spec/ISpecSize</span>
    <span class="tok-p">(</span><span class="tok-nf">size</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
      <span class="tok-c1">;; we kwno that is datatype has fixed size in bytes</span>
      <span class="tok-c1">;; that represents two int32.</span>
      <span class="tok-mi">8</span><span class="tok-p">)</span>

    <span class="tok-nv">spec/ISpec</span>
    <span class="tok-p">(</span><span class="tok-nb">read </span><span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">buff</span> <span class="tok-nv">pos</span><span class="tok-p">]</span>
      <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">readed</span> <span class="tok-nv">xvalue</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">spec/read</span> <span class="tok-p">(</span><span class="tok-nf">buf/int32</span><span class="tok-p">)</span> <span class="tok-nv">buff</span> <span class="tok-nv">pos</span><span class="tok-p">)</span>
            <span class="tok-p">[</span><span class="tok-nv">readed</span><span class="tok-o">&#39;</span> <span class="tok-nv">yvalue</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">spec/read</span> <span class="tok-p">(</span><span class="tok-nf">buf/int32</span><span class="tok-p">)</span> <span class="tok-nv">buff</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">pos</span> <span class="tok-nv">readed</span><span class="tok-p">))]</span>
        <span class="tok-p">[(</span><span class="tok-nb">+ </span><span class="tok-nv">readed</span> <span class="tok-nv">readed</span><span class="tok-o">&#39;</span><span class="tok-p">)</span>
         <span class="tok-p">(</span><span class="tok-nf">Point.</span> <span class="tok-nv">xvalue</span> <span class="tok-nv">yvalue</span><span class="tok-p">)]))</span>

    <span class="tok-p">(</span><span class="tok-nf">write</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">buff</span> <span class="tok-nv">pos</span> <span class="tok-nv">point</span><span class="tok-p">]</span>
      <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">written</span> <span class="tok-p">(</span><span class="tok-nf">spec/write</span> <span class="tok-p">(</span><span class="tok-nf">buf/int32</span><span class="tok-p">)</span> <span class="tok-nv">buff</span> <span class="tok-nv">pos</span> <span class="tok-p">(</span><span class="tok-ss">:x</span> <span class="tok-nv">point</span><span class="tok-p">))</span>
            <span class="tok-nv">written</span><span class="tok-o">&#39;</span> <span class="tok-p">(</span><span class="tok-nf">spec/write</span> <span class="tok-p">(</span><span class="tok-nf">buf/int32</span><span class="tok-p">)</span> <span class="tok-nv">buff</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">pos</span> <span class="tok-nv">written</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-ss">:y</span> <span class="tok-nv">point</span><span class="tok-p">))]</span>
        <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">written</span> <span class="tok-nv">written</span><span class="tok-o">&#39;</span><span class="tok-p">)))))</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example using the previously defined typespec</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">mypoint</span> <span class="tok-p">(</span><span class="tok-nf">Point.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-nf">buf/write!</span> <span class="tok-nv">buffer</span> <span class="tok-nv">mypoint</span> <span class="tok-nv">point-spec</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 8</span>

<span class="tok-p">(</span><span class="tok-nf">buf/read*</span> <span class="tok-nv">buffer</span> <span class="tok-nv">point-spec</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [8 #user.Point{:x 1, :y 2}]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Moreover, knowing how it can be done in low level way, you can simplify this
concrete step using <strong>compose</strong> function. The compose function is a type spec
constructor that helps map an indexed type spec to specific user defined type.</p>
</div>
<div class="paragraph">
<p>Let see how the previous code can be simplified in much less boilerplate code:</p>
</div>
<div class="listingblock">
<div class="title">Example using <strong>compose</strong> function.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-kd">defrecord </span><span class="tok-nv">Point</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">mypoint</span> <span class="tok-p">(</span><span class="tok-nf">Point.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">point-spec</span> <span class="tok-p">(</span><span class="tok-nf">buf/compose</span> <span class="tok-nv">-&gt;Point</span> <span class="tok-p">[</span><span class="tok-nv">buf/int32</span> <span class="tok-nv">buf/int32</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">buf/write!</span> <span class="tok-nv">buffer</span> <span class="tok-nv">mypoint</span> <span class="tok-nv">point-spec</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 8</span>

<span class="tok-p">(</span><span class="tok-nf">buf/read*</span> <span class="tok-nv">buffer</span> <span class="tok-nv">point-spec</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [8 #user.Point{:x 1, :y 2}]</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_additional_info"><a class="link" href="#_additional_info">4. Additional info</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="supported-bytebuffers"><a class="link" href="#supported-bytebuffers">4.1. Supported byte buffers</a></h3>
<div class="paragraph">
<p>This is a complete table of supported byte buffer implementations and type of
byte buffers:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Platform</th>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Params</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clojure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Heap NIO ByteBuffer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{:type :heap :impl :nio}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clojure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Direct NIO ByteBuffer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{:type :direct :impl :nio}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clojure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Heap Netty ByteBuf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{:type :heap :impl :netty}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clojure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Direct Netty ByteBuf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{:type :direct :impl :netty}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ClojureScript</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Heap ES6 ArrayBuffer/DataView</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{:type :heap :impl :es6}</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_supported_typespecs"><a class="link" href="#_supported_typespecs">4.2. Supported typespecs</a></h3>
<div class="paragraph">
<p>This is a complete list of supported plain value type spec:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Size (in bytes)</th>
<th class="tableblock halign-left valign-top">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>buf/int16</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>buf/int32</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>buf/int64</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Only on jvm</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>buf/float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>buf/double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>buf/bool</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>buf/byte</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>buf/string</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixed length string</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>buf/string*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4+N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arbitrary length string</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Independently if a spec is a value spec or a composition of value specs, all them
implements the same abstraction and can be used in read or write operations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_byte_order"><a class="link" href="#_byte_order">4.3. Byte order</a></h3>
<div class="paragraph">
<p>All the builtin implementations uses the <code>:big-endian</code> as default byte order. That
value can be canched at any time using the provided <code><strong>byteorder</strong></code> dynamic var on
the <code>octet.buffer</code> namespace.</p>
</div>
<div class="paragraph">
<p>Let see a little example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">octet.buffer</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">myspec</span> <span class="tok-p">(</span><span class="tok-nf">buf/spec</span> <span class="tok-nv">buf/string*</span> <span class="tok-nv">buf/string*</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">buffer</span>
  <span class="tok-p">(</span><span class="tok-nf">buf/with-byte-order</span> <span class="tok-ss">:little-endian</span>
    <span class="tok-p">(</span><span class="tok-nf">buf/into</span> <span class="tok-nv">myspec</span> <span class="tok-p">[</span><span class="tok-s">&quot;hello&quot;</span> <span class="tok-s">&quot;world!&quot;</span><span class="tok-p">])))</span>

<span class="tok-p">(</span><span class="tok-nf">buf/get-capacity</span> <span class="tok-nv">buffer</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 19</span>

<span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffer</span> <span class="tok-nv">myspec</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; BufferUnderflowException (because of incorect byte order)</span>

<span class="tok-p">(</span><span class="tok-nf">buf/with-byte-order</span> <span class="tok-ss">:little-endian</span>
  <span class="tok-p">(</span><span class="tok-nf">buf/read</span> <span class="tok-nv">buffer</span> <span class="tok-nv">myspec</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [&quot;hello&quot;, &quot;world!&quot;]</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_faq"><a class="link" href="#_faq">5. FAQ</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>What is the difference with <em>clojurewerkz/buffy</em>?</strong></p>
</div>
<div class="paragraph">
<p><strong>Buffy</strong> is a excelent library, and I have used it in some circumstances, but is has
some things that I personally don&#8217;t like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It works only with netty bytebuf and I need an abstraction for work with
different implementations, including in clojurescript.</p>
</li>
<li>
<p>It has slightly strange and not uniform api when dynamic frames (arbitrary
length size types) are used. <em>octet</em> offers unified api for both type of specs.</p>
</li>
<li>
<p>It wraps bytebuf in a self defined type. <em>octet</em> is a lightweight abstraction
that works over host implementations, without wrapping them.</p>
</li>
<li>
<p>It not has support for ClojureScript</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>What is the difference with <em>ztellman/gloss</em>?</strong></p>
</div>
<div class="paragraph">
<p>Gloss is also similiar project, and has similar purposes, but it has several
differeces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has a limited set of types. Octet has an extensible abstraction for build own
arbitrary type specs.</p>
</li>
<li>
<p>It only works with nio as buffer implementations. Octet exposes an extensible
abstraction and support few differents out of the box.</p>
</li>
<li>
<p>In my opinion it has slightly ugly and unclear api.</p>
</li>
<li>
<p>Seems not very maintained (has issues from 2013).</p>
</li>
<li>
<p>It not has support for ClojureScript.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_contribute"><a class="link" href="#_how_to_contribute">6. How to Contribute?</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_philosophy"><a class="link" href="#_philosophy">6.1. Philosophy</a></h3>
<div class="paragraph">
<p>Five most important rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Beautiful is better than ugly.</p>
</li>
<li>
<p>Explicit is better than implicit.</p>
</li>
<li>
<p>Simple is better than complex.</p>
</li>
<li>
<p>Complex is better than complicated.</p>
</li>
<li>
<p>Readability counts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All contributions to <em>octet</em> should keep these important rules in mind.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contributing"><a class="link" href="#_contributing">6.2. Contributing</a></h3>
<div class="paragraph">
<p>Unlike Clojure and other Clojure contributed libraries <em>octet</em> does not have many
restrictions for contributions. Just open an issue or pull request.</p>
</div>
</div>
<div class="sect2">
<h3 id="_source_code"><a class="link" href="#_source_code">6.3. Source Code</a></h3>
<div class="paragraph">
<p><em>octet</em> is open source and can be found on
<a href="https://github.com/funcool/octet">github</a>.</p>
</div>
<div class="paragraph">
<p>You can clone the public repository with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>git clone https://github.com/funcool/octet</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_run_tests"><a class="link" href="#_run_tests">6.4. Run tests</a></h3>
<div class="paragraph">
<p>For running tests just execute this (for clojure):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>lein test</code></pre>
</div>
</div>
<div class="paragraph">
<p>And this for for clojurescript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>./scripts/build
node ./out/tests.js</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_license"><a class="link" href="#_license">6.5. License</a></h3>
<div class="paragraph">
<p><em>octet</em> is licensed under BSD (2-Clause) license:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Copyright (c) 2015-2016 Andrey Antukh &lt;niwi@niwi.nz&gt;
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-04-24 09:04:16 CEST
</div>
</div>
</body>
</html>
